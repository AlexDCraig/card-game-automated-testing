1. 	You don't need to consider a partition where cards is NULL because the method will crash the program if it gets that as input. 
	No. We consider every possible state in 3 partitions: the first state, where the deck is empty, the second state where the deck is full, and the third state where the deck is twice as full, i.e. there are 2 copies of each card.
	No. We consider every possible state in 3 partitions: the first state where we remove the first card in the deck, the second state where we remove the last card in the deck, and a third state where we remove a card from somewhere in the middle (i.e. not the first nor the last but in between).
	I think the partitioning is complete. It would be silly to consider EVERY value between the first and last cards (which are obvious base cases that are needed) so I think the partition we've done here where you just consider a random card between the first and last makes sense because whatever happens with this input will hold for any of the other inputs in this partition.
2.	It fails at least block b6, deck consisting of two decks removing a card from not the first or last.
3. 	It means that partition b6 is sensitive to the group of values which violate it. 1 is within 0 < x < cards.size() - 1, and so is 2... But if 2 fails and 1 doesn't, it means that our partition b6 passes with some and fails with others. Perhaps it should be redefined to cover more specific sets of input.	
